name: Build MPC-BE with Ultimate Static FFmpeg

on:
  workflow_dispatch:
    inputs:
      mpc_be_branch:
        description: 'MPC-BE branch/tag to build'
        required: false
        default: 'master'
      build_config:
        description: 'Build configuration'
        required: false
        default: 'Release'
        type: choice
        options:
        - Debug
        - Release
      include_debug_symbols:
        description: 'Include debug symbols'
        required: false
        default: false
        type: boolean
      cache_strategy:
        description: 'Cache strategy'
        required: false
        default: 'smart'
        type: choice
        options:
        - smart
        - daily
        - weekly
        - force_new
  schedule:
    - cron: '0 6 * * 1'  # æ¯é€±ä¸€æ—©ä¸Š 6 é»è‡ªå‹•ç·¨è­¯

env:
  VCPKG_BINARY_SOURCES: 'clear;x-gha,readwrite'

jobs:
  build-ultimate-ffmpeg:
    runs-on: windows-latest
    outputs:
      ffmpeg-artifact-name: ${{ steps.artifact-name.outputs.name }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup MSYS2
      uses: msys2/setup-msys2@v2
      with:
        msystem: MINGW64
        update: true
        install: >-
          mingw-w64-x86_64-toolchain
          mingw-w64-x86_64-cmake
          mingw-w64-x86_64-ninja
          mingw-w64-x86_64-nasm
          mingw-w64-x86_64-yasm
          mingw-w64-x86_64-pkg-config
          mingw-w64-x86_64-zlib
          mingw-w64-x86_64-rust
          mingw-w64-x86_64-diffutils
          mingw-w64-x86_64-libvpl
          mingw-w64-x86_64-SDL2
          autoconf
          automake
          libtool
          make
          git
          curl
          wget
          unzip
          zip
          tar
          xz
          patch

    - name: Generate FFmpeg cache key
      id: cache-key
      shell: msys2 {0}
      run: |
        # æ ¹æ“šç­–ç•¥ç”Ÿæˆä¸åŒçš„ç·©å­˜éµ
        STRATEGY="${{ github.event.inputs.cache_strategy || 'smart' }}"
        DATE=$(date -u +"%Y-%m-%d")
        WEEK=$(date -u +"%Y-W%U")
        
        case "$STRATEGY" in
          "daily")
            CACHE_KEY="ultimate-ffmpeg-daily-${DATE}"
            RESTORE_BASE="ultimate-ffmpeg-daily"
            ;;
          "weekly") 
            CACHE_KEY="ultimate-ffmpeg-weekly-${WEEK}"
            RESTORE_BASE="ultimate-ffmpeg-weekly"
            ;;
          "force_new")
            CACHE_KEY="ultimate-ffmpeg-force-$(date -u +"%Y%m%d-%H%M%S")"
            RESTORE_BASE="ultimate-ffmpeg-force"
            ;;
          "smart"|*)
            # æ™ºèƒ½ç·©å­˜ï¼šåŸºæ–¼ä¸»è¦çµ„ä»¶çš„ commit
            X264_COMMIT=$(curl -s "https://api.github.com/repos/mirror/x264/commits/master" | grep -o '"sha":"[^"]*' | head -1 | cut -d'"' -f4 | cut -c1-8 2>/dev/null || echo "unknown")
            FFMPEG_COMMIT=$(curl -s "https://api.github.com/repos/FFmpeg/FFmpeg/commits/master" | grep -o '"sha":"[^"]*' | head -1 | cut -d'"' -f4 | cut -c1-8 2>/dev/null || echo "unknown")
            
            CACHE_KEY="ultimate-ffmpeg-smart-${DATE}-${FFMPEG_COMMIT}-${X264_COMMIT}"
            RESTORE_BASE="ultimate-ffmpeg-smart-${DATE}"
            ;;
        esac
        
        # å¦‚æœå¼·åˆ¶é‡å»ºï¼Œä¿®æ”¹ç·©å­˜éµ
        if [[ "${{ github.event.inputs.force_rebuild_ffmpeg }}" == "true" ]]; then
          CACHE_KEY="${CACHE_KEY}-force-$(date -u +"%H%M%S")"
        fi
        
        echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "restore_base=$RESTORE_BASE" >> $GITHUB_OUTPUT
        echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
        
        echo "Cache strategy: $STRATEGY"
        echo "FFmpeg cache key: $CACHE_KEY"
        echo "Restore base: $RESTORE_BASE"

    - name: Cache Ultimate FFmpeg build
      id: cache-ffmpeg
      uses: actions/cache@v4
      with:
        path: |
          D:/ffmpeg-build/
        key: ${{ steps.cache-key.outputs.key }}
        restore-keys: |
          ${{ steps.cache-key.outputs.restore_base }}
          ultimate-ffmpeg-2024-
          ultimate-ffmpeg-

    - name: Set environment variables
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        export PREFIX="/d/ffmpeg-build"
        echo "PREFIX=$PREFIX" >> $GITHUB_ENV
        mkdir -p $PREFIX

        # é‡å° MPC-BE å„ªåŒ–çš„ç·¨è­¯åƒæ•¸
        STATIC_FLAGS="-O3 -static -static-libgcc -static-libstdc++ -fno-lto -D_WIN32_WINNT=0x0601 -march=x86-64-v2"
        echo "CFLAGS=$STATIC_FLAGS -I$PREFIX/include" >> $GITHUB_ENV
        echo "CXXFLAGS=$STATIC_FLAGS -std=c++17 -I$PREFIX/include" >> $GITHUB_ENV
        echo "LDFLAGS=$STATIC_FLAGS -L$PREFIX/lib" >> $GITHUB_ENV

        echo "PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig" >> $GITHUB_ENV
        echo "PATH=$PREFIX/bin:$PATH" >> $GITHUB_ENV

    # æ‰€æœ‰ç·¨è§£ç¢¼å™¨ç·¨è­¯æ­¥é©Ÿï¼ˆåªåœ¨ç·©å­˜æœªå‘½ä¸­æ™‚åŸ·è¡Œï¼‰
    - name: Build x264
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://code.videolan.org/videolan/x264.git
        cd x264
        ./configure --prefix=$PREFIX --enable-static --disable-opencl --disable-cli --disable-avs --disable-swscale --disable-lavf --disable-ffms --disable-gpac --disable-lsmash
        make -j$(nproc)
        make install

    - name: Install prebuilt x265
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone https://github.com/LvzBxLzSyP/x265.git
        cd x265
        mkdir -p $PREFIX/include $PREFIX/lib
        cp -r ./include/* $PREFIX/include/
        cp -r ./lib/* $PREFIX/lib/

    - name: Build SVT-AV1
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://gitlab.com/AOMediaCodec/SVT-AV1.git
        cd SVT-AV1
        cmake -G "Ninja" \
          -DCMAKE_INSTALL_PREFIX=$PREFIX \
          -DBUILD_SHARED_LIBS=OFF \
          -DBUILD_APPS=OFF \
          -DBUILD_DEC=OFF \
          -DCMAKE_C_FLAGS="$CFLAGS" \
          -DCMAKE_CXX_FLAGS="$CXXFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS" \
          .
        ninja -j$(nproc)
        ninja install

    - name: Build rav1e
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        export PATH="/mingw64/bin:$PATH"
        export CARGO_BUILD_TARGET=x86_64-pc-windows-gnu
        git clone --depth=1 https://github.com/xiph/rav1e.git
        cd rav1e
        cargo install cargo-c --force
        cargo cinstall --release --target x86_64-pc-windows-gnu \
          --library-type staticlib \
          --prefix="$PREFIX"

    - name: Build libaom
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://aomedia.googlesource.com/aom.git
        mkdir -p aom/build && cd aom/build
        cmake .. -G "Ninja" \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_INSTALL_PREFIX=$PREFIX \
          -DENABLE_SHARED=OFF \
          -DENABLE_NASM=ON \
          -DENABLE_TOOLS=OFF \
          -DENABLE_EXAMPLES=OFF \
          -DENABLE_DOCS=OFF \
          -DENABLE_TESTS=OFF \
          -DCMAKE_C_FLAGS="$CFLAGS" \
          -DCMAKE_CXX_FLAGS="$CXXFLAGS"
        ninja -j$(nproc)
        ninja install

    - name: Build libvpx
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://chromium.googlesource.com/webm/libvpx.git
        cd libvpx
        LDFLAGS="$LDFLAGS" ./configure \
          --prefix=$PREFIX \
          --disable-examples \
          --disable-unit-tests \
          --disable-tools \
          --disable-docs \
          --enable-vp8 \
          --enable-vp9 \
          --enable-vp9-highbitdepth \
          --enable-static \
          --disable-shared \
          --extra-cflags="$CFLAGS"
        make -j$(nproc)
        make install

    # çœç•¥å…¶ä»–ç·¨è§£ç¢¼å™¨æ­¥é©Ÿï¼Œä¿æŒèˆ‡åŸé…ç½®ç›¸åŒ...
    - name: Build VVenC
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://github.com/fraunhoferhhi/vvenc.git
        export CFLAGS="-O2 -static -static-libgcc -fno-lto -I$PREFIX/include"
        export CXXFLAGS="-O2 -static -static-libgcc -static-libstdc++ -fno-lto -std=c++17 -I$PREFIX/include"
        cd vvenc
        cmake \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_C_FLAGS_RELEASE="$CFLAGS" \
          -DCMAKE_CXX_FLAGS_RELEASE="$CXXFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS_RELEASE="$LDFLAGS" \
          -DVVENC_ENABLE_LINK_TIME_OPT=OFF \
          -G Ninja
        ninja -j$(nproc)
        ninja install
        
    - name: Build VVdeC
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://github.com/fraunhoferhhi/vvdec.git
        export CFLAGS="-O2 -static -static-libgcc -fno-lto -I$PREFIX/include"
        export CXXFLAGS="-O2 -static -static-libgcc -static-libstdc++ -fno-lto -std=c++17 -I$PREFIX/include"
        cd vvdec
        cmake \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_C_FLAGS_RELEASE="$CFLAGS" \
          -DCMAKE_CXX_FLAGS_RELEASE="$CXXFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS_RELEASE="$LDFLAGS" \
          -DVVDEC_ENABLE_LINK_TIME_OPT=OFF \
          -G Ninja
        ninja -j$(nproc)
        ninja install

    - name: Build libxeve
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone https://github.com/mpeg5/xeve.git
        cd xeve
        cmake -G Ninja \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_C_FLAGS_RELEASE="$CFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS_RELEASE="$LDFLAGS" \
          -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=OFF \
          .
        ninja -j$(nproc)
        cmake --install . --component Development

    - name: Build libxevd
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone https://github.com/mpeg5/xevd.git
        cd xevd
        cmake -G Ninja \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_C_FLAGS_RELEASE="$CFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS_RELEASE="$LDFLAGS" \
          -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=OFF \
          .
        ninja -j$(nproc)
        cmake --install . --component Development

    - name: Build freetype2
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://gitlab.freedesktop.org/freetype/freetype.git
        cd freetype
        ./autogen.sh
        ./configure --prefix=$PREFIX --enable-static --disable-shared --without-bzip2 --without-png CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"
        make -j$(nproc)
        make install
        cd ..

    - name: Build libmp3lame
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        wget https://downloads.sourceforge.net/project/lame/lame/3.100/lame-3.100.tar.gz
        tar xzf lame-3.100.tar.gz
        cd lame-3.100
        ./configure --prefix=$PREFIX --disable-shared --enable-static --disable-frontend CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"
        make -j$(nproc)
        make install
        cd ..

    - name: Build libogg
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone https://github.com/xiph/ogg.git
        cd ogg
        mkdir build && cd build
        cmake .. -G Ninja \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_SHARED_LIBS=OFF \
          -DCMAKE_C_FLAGS="$CFLAGS" \
          -DCMAKE_CXX_FLAGS="$CXXFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS"
        ninja -j$(nproc)
        ninja install
        cd ../..

    - name: Build libflac
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone https://github.com/xiph/flac.git
        cd flac
        mkdir build && cd build
        cmake .. -G Ninja \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_SHARED_LIBS=OFF \
          -DINSTALL_MANPAGES=OFF \
          -DCMAKE_C_FLAGS="$CFLAGS" \
          -DCMAKE_CXX_FLAGS="$CXXFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS"
        ninja -j$(nproc)
        ninja install
        cd ../..

    - name: Build libvorbis
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone https://github.com/xiph/vorbis.git
        cd vorbis
        mkdir build && cd build
        cmake .. -G Ninja \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
          -DBUILD_SHARED_LIBS=OFF \
          -DINSTALL_MANPAGES=OFF \
          -DCMAKE_C_FLAGS="$CFLAGS" \
          -DCMAKE_CXX_FLAGS="$CXXFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS"
        ninja -j$(nproc)
        ninja install
        cd ../..

    - name: Build fribidi
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        wget https://github.com/fribidi/fribidi/releases/download/v1.0.13/fribidi-1.0.13.tar.xz
        tar xf fribidi-1.0.13.tar.xz
        cd fribidi-1.0.13
        ./configure --prefix=$PREFIX --disable-shared --enable-static --disable-docs CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"
        make -j$(nproc)
        make install
        cd ..

    - name: Build harfbuzz
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        wget https://github.com/harfbuzz/harfbuzz/releases/download/11.3.2/harfbuzz-11.3.2.tar.xz
        tar xf harfbuzz-11.3.2.tar.xz
        cd harfbuzz-11.3.2
        mkdir build && cd build
        export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
        cmake .. -G Ninja \
          -DCMAKE_INSTALL_PREFIX="$PREFIX" \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_SHARED_LIBS=OFF \
          -DHB_HAVE_FREETYPE=ON \
          -DHB_HAVE_GLIB=OFF \
          -DHB_HAVE_GOBJECT=OFF \
          -DHB_HAVE_CAIRO=OFF \
          -DHB_HAVE_FONTCONFIG=OFF \
          -DHB_HAVE_ICU=OFF \
          -DCMAKE_C_FLAGS="$CFLAGS" \
          -DCMAKE_CXX_FLAGS="$CXXFLAGS" \
          -DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS"
        ninja -j$(nproc)
        ninja install
        cd ../..

    - name: Build libass
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://github.com/libass/libass.git
        cd libass
        export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
        ./autogen.sh
        ./configure --prefix=$PREFIX --disable-shared --enable-static CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"
        make -j$(nproc)
        make install
        cd ..

    - name: Build opus
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://github.com/xiph/opus.git
        cd opus
        ./autogen.sh
        ./configure --prefix=$PREFIX --disable-shared --enable-static CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"
        make -j$(nproc)
        make install
        cd ..

    - name: Install NVENC headers
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://github.com/FFmpeg/nv-codec-headers.git
        cd nv-codec-headers
        make PREFIX=$PREFIX
        make install PREFIX=$PREFIX
        cd ..

    - name: Build Ultimate FFmpeg for MPC-BE
      if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
      shell: msys2 {0}
      run: |
        git clone --depth=1 https://github.com/FFmpeg/FFmpeg.git ffmpeg
        cd ffmpeg
        export PATH="/mingw64/bin:$PATH"
        export PKG_CONFIG_PATH="$PREFIX/lib/pkgconfig:/mingw64/lib/pkgconfig"

        # æª¢æŸ¥ x265 æ˜¯å¦å¯ç”¨
        X265_FLAG=""
        if pkg-config --exists x265 || [ -f "$PREFIX/lib/libx265.a" ]; then
          X265_FLAG="--enable-libx265"
        fi

        # æ‡‰ç”¨ VVC è§£ç¢¼è£œä¸
        wget -O libvvdec.patch https://raw.githubusercontent.com/wiki/fraunhoferhhi/vvdec/data/patch/v7-0001-avcodec-add-external-dec-libvvdec-for-H266-VVC.patch
        git apply libvvdec.patch || echo "Patch may already be applied or not needed"

        # é‡å° MPC-BE å„ªåŒ–çš„ FFmpeg é…ç½®
        ./configure \
          --prefix=$PREFIX \
          --pkg-config-flags="--static" \
          --extra-cflags="$CFLAGS -DWIN32_LEAN_AND_MEAN" \
          --extra-cxxflags="$CXXFLAGS" \
          --extra-ldflags="$LDFLAGS" \
          --extra-ldexeflags="$LDFLAGS -L/d/ffmpeg-build/lib/xevd -L/d/ffmpeg-build/lib/xeve -Wl,--whole-archive -lstdc++ -Wl,--no-whole-archive -Wl,-Bstatic" \
          --extra-libs="-lpthread -lm -lz -lws2_32 -lsecur32 -lbcrypt -lwinmm -ldxguid" \
          --enable-static \
          --disable-shared \
          --disable-programs \
          --disable-doc \
          --disable-htmlpages \
          --disable-manpages \
          --disable-podpages \
          --disable-txtpages \
          --enable-gpl \
          --enable-version3 \
          --disable-w32threads \
          --enable-pthreads \
          --enable-asm \
          --enable-mmx \
          --enable-sse \
          --enable-sse2 \
          --enable-sse3 \
          --enable-sse4 \
          --enable-sse42 \
          --enable-avx \
          --enable-avx2 \
          --enable-libx264 \
          $X265_FLAG \
          --enable-librav1e \
          --enable-libsvtav1 \
          --enable-libaom \
          --enable-libvpx \
          --enable-libvvenc \
          --enable-libvvdec \
          --enable-libxeve \
          --enable-libxevd \
          --enable-libmp3lame \
          --enable-libopus \
          --enable-libvorbis \
          --enable-libass \
          --enable-libfreetype \
          --enable-nvenc \
          --enable-nvdec \
          --enable-cuda \
          --enable-libvpl \
          --enable-dxva2 \
          --enable-d3d11va \
          --enable-mediafoundation \
          --enable-schannel || cat ffbuild/config.log

        make -j$(nproc)
        make install

        # ç‚º MPC-BE å‰µå»ºç‰¹æ®Šçš„é…ç½®æ–‡ä»¶
        cat > $PREFIX/ffmpeg-mpc-be.pc << EOF
        prefix=$PREFIX
        exec_prefix=\${prefix}
        libdir=\${exec_prefix}/lib
        includedir=\${prefix}/include

        Name: FFmpeg for MPC-BE
        Description: Ultimate static FFmpeg build for MPC-BE
        Version: $(cat VERSION)
        Requires:
        Libs: -L\${libdir} -lavformat -lavcodec -lavutil -lswscale -lswresample -lavfilter -lavdevice
        Libs.private: -lpthread -lm -lz -lws2_32 -lsecur32 -lbcrypt -lwinmm -ldxguid
        Cflags: -I\${includedir}
        EOF

    - name: Set artifact name
      id: artifact-name
      run: |
        $date = Get-Date -Format "yyyy-MM-dd-HH-mm"
        $name = "ultimate-ffmpeg-$date"
        echo "name=$name" >> $env:GITHUB_OUTPUT

    - name: Upload FFmpeg artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.artifact-name.outputs.name }}
        path: |
          D:/ffmpeg-build/
        retention-days: 7

  build-mpc-be:
    needs: build-ultimate-ffmpeg
    runs-on: windows-2022
    strategy:
      matrix:
        platform: [x64]
        configuration: [Release, Debug]
        exclude:
          - configuration: Debug
            platform: x64
          
    steps:
    - name: Checkout MPC-BE
      uses: actions/checkout@v4
      with:
        repository: 'Aleksoid1978/MPC-BE'
        ref: ${{ github.event.inputs.mpc_be_branch || 'master' }}
        submodules: recursive
        fetch-depth: 0

    - name: Setup MSBuild and Windows SDK
      uses: microsoft/setup-msbuild@v2

    - name: Install compatible Windows SDK
      shell: powershell
      run: |
        Write-Host "Installing Windows SDK..."
        
        # ä¸‹è¼‰ä¸¦å®‰è£ Windows SDK 10.0.22621.0 (æ¨è–¦ç‰ˆæœ¬)
        $sdkUrl = "https://download.microsoft.com/download/1/c/3/1c3d5161-d9e9-4e4b-9b43-b70fe3be268c/windowssdk/winsdksetup.exe"
        $sdkInstaller = "$env:TEMP\winsdksetup.exe"
        
        try {
          Write-Host "Downloading Windows SDK installer..."
          Invoke-WebRequest -Uri $sdkUrl -OutFile $sdkInstaller -UseBasicParsing
          
          Write-Host "Installing Windows SDK (this may take several minutes)..."
          $installArgs = @(
            "/quiet"
            "/norestart" 
            "/features"
            "OptionId.WindowsPerformanceToolkit"
            "OptionId.WindowsDesktopDebuggers"
            "OptionId.MSIInstallTools"
            "OptionId.WindowsSoftwareLogoToolkit"
            "OptionId.IpOverUsb"
            "OptionId.NETFXSDK"
            "OptionId.UWPManaged"
            "OptionId.UWPCpp"
            "OptionId.SigningTools"
          )
          
          Start-Process -FilePath $sdkInstaller -ArgumentList $installArgs -Wait -NoNewWindow
          Write-Host "âœ… Windows SDK installation completed"
        } catch {
          Write-Warning "SDK installation failed, will use available version"
        }

    - name: Check available Windows SDKs
      shell: powershell
      run: |
        Write-Host "=== Available Windows SDKs ==="
        $sdkPaths = @(
          "C:\Program Files (x86)\Windows Kits\10\Include",
          "C:\Program Files\Windows Kits\10\Include"
        )
        
        $availableSDKs = @()
        foreach ($path in $sdkPaths) {
          if (Test-Path $path) {
            $versions = Get-ChildItem $path | Where-Object { $_.Name -match "^10\." } | Sort-Object Name -Descending
            foreach ($version in $versions) {
              $availableSDKs += $version.Name
              Write-Host "Found SDK: $($version.Name)"
            }
          }
        }
        
        if ($availableSDKs.Count -eq 0) {
          Write-Error "No Windows 10 SDK found!"
          # å˜—è©¦ä½¿ç”¨é è¨­ SDK
          $availableSDKs = @("10.0.22621.0", "10.0.19041.0", "10.0.18362.0")
          Write-Host "Using fallback SDK versions"
        }
        
        # é¸æ“‡æœ€æ–°çš„å¯ç”¨ SDK æˆ–ç›¸å®¹ç‰ˆæœ¬
        $preferredSDKs = @("10.0.22621.0", "10.0.20348.0", "10.0.19041.0", "10.0.18362.0")
        $selectedSDK = $null
        
        foreach ($preferred in $preferredSDKs) {
          if ($availableSDKs -contains $preferred) {
            $selectedSDK = $preferred
            break
          }
        }
        
        if (-not $selectedSDK) {
          $selectedSDK = $availableSDKs[0]
        }
        
        Write-Host "Selected SDK: $selectedSDK"
        echo "WINDOWS_SDK_VERSION=$selectedSDK" >> $env:GITHUB_ENV
        
        # æª¢æŸ¥ Visual Studio ç‰ˆæœ¬
        Write-Host "`n=== Visual Studio Information ==="
        $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
        if (Test-Path $vsWhere) {
          $vsPath = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          $vsVersion = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationVersion
          Write-Host "VS Path: $vsPath"
          Write-Host "VS Version: $vsVersion"
          
          # è¨­ç½®æ­£ç¢ºçš„ VCTargetsPath
          $vcTargetsPath = Join-Path $vsPath "MSBuild\Microsoft\VC\v170"
          if (Test-Path $vcTargetsPath) {
            echo "VC_TARGETS_PATH=$vcTargetsPath" >> $env:GITHUB_ENV
            Write-Host "VC Targets Path: $vcTargetsPath"
          }
        }

    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgGitCommitId: '897ba2ab4c4c776b985ab1f599548fcf3ae598ba'

    - name: Download Ultimate FFmpeg
      uses: actions/download-artifact@v4
      with:
        name: ${{ needs.build-ultimate-ffmpeg.outputs.ffmpeg-artifact-name }}
        path: ffmpeg-ultimate/

    - name: Configure MPC-BE for Ultimate FFmpeg
      shell: powershell
      run: |
        # è¨­ç½®ç’°å¢ƒè®Šæ•¸
        $ffmpegRoot = "${{ github.workspace }}\ffmpeg-ultimate"
        echo "FFMPEG_ROOT=$ffmpegRoot" >> $env:GITHUB_ENV
        echo "PKG_CONFIG_PATH=$ffmpegRoot\lib\pkgconfig" >> $env:GITHUB_ENV

        # æª¢æŸ¥ FFmpeg æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if (-not (Test-Path "$ffmpegRoot\include\libavcodec\avcodec.h")) {
          Write-Error "FFmpeg headers not found in $ffmpegRoot"
          Get-ChildItem $ffmpegRoot -Recurse | Select-Object Name, Directory | Head -20
          exit 1
        }
        
        Write-Host "FFmpeg Ultimate found at: $ffmpegRoot"
        Get-ChildItem "$ffmpegRoot\lib" -Filter "*.lib" | Select-Object Name | Head -10

        # å°‹æ‰¾é…ç½®é ­æ–‡ä»¶ä½ç½®
        $configPaths = @(
          "src\mpc-be_config.h",
          "include\mpc-be_config.h", 
          "src\config.h",
          "config.h"
        )
        
        $configPath = $null
        foreach ($path in $configPaths) {
          if (Test-Path $path) {
            $configPath = $path
            break
          }
        }
        
        # å¦‚æœæ‰¾ä¸åˆ°ç¾æœ‰é…ç½®æ–‡ä»¶ï¼Œå‰µå»ºæ–°çš„
        if (-not $configPath) {
          $configPath = "src\mpc-be_ultimate_config.h"
          New-Item -ItemType Directory -Path (Split-Path $configPath) -Force -ErrorAction SilentlyContinue
        }

        # å‰µå»º MPC-BE è‡ªå®šç¾©é…ç½®
        $configHeader = @"
        #pragma once
        #ifndef MPC_BE_ULTIMATE_CONFIG_H
        #define MPC_BE_ULTIMATE_CONFIG_H

        // Ultimate FFmpeg æ”¯æ´
        #define USE_STATIC_FFMPEG 1
        #define FFMPEG_SUPPORT 1
        #define HAVE_FFMPEG 1

        // æœ€æ–°ç·¨è§£ç¢¼å™¨æ”¯æ´
        #define HAVE_AV1_DECODE 1
        #define HAVE_VVC_DECODE 1
        #define HAVE_EVC_SUPPORT 1
        #define HAVE_ULTIMATE_CODECS 1

        // ç¡¬é«”åŠ é€Ÿæ”¯æ´
        #define HAVE_DXVA2 1
        #define HAVE_D3D11VA 1
        #define HAVE_NVDEC 1
        #define HAVE_QSV 1

        #endif // MPC_BE_ULTIMATE_CONFIG_H
        "@
        
        $configHeader | Out-File -FilePath $configPath -Encoding UTF8
        Write-Host "Created config file: $configPath"

        # å¦‚æœå­˜åœ¨ä¸»é…ç½®æ–‡ä»¶ï¼Œé€²è¡Œä¿®æ”¹
        if ($configPath -ne "src\mpc-be_ultimate_config.h") {
          $content = Get-Content $configPath -Raw
          if ($content -notmatch "USE_STATIC_FFMPEG") {
            $content += "`n#define USE_STATIC_FFMPEG 1`n"
          }
          if ($content -notmatch "FFMPEG_SUPPORT") {
            $content += "`n#define FFMPEG_SUPPORT 1`n"
          }
          $content += "`n#include `"mpc-be_ultimate_config.h`"`n"
          $content | Out-File $configPath -Encoding UTF8
        }

    - name: Find and patch MPC-BE project files
      shell: powershell
      run: |
        # é¦–å…ˆæ‰¾åˆ° MPC-BE çš„å¯¦éš›é …ç›®çµæ§‹
        Write-Host "Exploring MPC-BE directory structure..."
        Get-ChildItem -Recurse -Name "*.vcxproj" | Head -10
        Get-ChildItem -Recurse -Name "*.sln" | Head -5
        
        # æ‰¾åˆ°ä¸»é …ç›®æ–‡ä»¶
        $possiblePaths = @(
          "src\mpc-be\mpc-be.vcxproj",
          "mpc-be.vcxproj", 
          "src\apps\mpc-be\mpc-be.vcxproj",
          "src\mpc-be64.vcxproj"
        )
        
        $vcxprojPath = $null
        foreach ($path in $possiblePaths) {
          if (Test-Path $path) {
            $vcxprojPath = $path
            Write-Host "Found MPC-BE project file: $path"
            break
          }
        }
        
        if (-not $vcxprojPath) {
          # å¦‚æœæ‰¾ä¸åˆ°ï¼Œæœç´¢æ‰€æœ‰ .vcxproj æ–‡ä»¶
          $allProjects = Get-ChildItem -Recurse -Filter "*.vcxproj" | Where-Object { $_.Name -like "*mpc-be*" }
          if ($allProjects.Count -gt 0) {
            $vcxprojPath = $allProjects[0].FullName
            Write-Host "Found alternative project file: $vcxprojPath"
          } else {
            Write-Error "Could not find MPC-BE project file"
            Get-ChildItem -Recurse -Filter "*.vcxproj" | Select-Object Name, Directory
            exit 1
          }
        }
        
        # è®€å–ä¸¦ä¿®æ”¹é …ç›®æ–‡ä»¶
        $content = Get-Content $vcxprojPath -Raw
        
        # æ·»åŠ  Ultimate FFmpeg åŒ…å«ç›®éŒ„
        $ffmpegInclude = "`$(FFMPEG_ROOT)\include"
        $content = $content -replace '(<AdditionalIncludeDirectories>)', "`$1$ffmpegInclude;"
        
        # æ·»åŠ  Ultimate FFmpeg åº«ç›®éŒ„
        $ffmpegLibDir = "`$(FFMPEG_ROOT)\lib"
        $content = $content -replace '(<AdditionalLibraryDirectories>)', "`$1$ffmpegLibDir;"
        
        # æ·»åŠ å®Œæ•´çš„ FFmpeg åº«ä¾è³´ï¼ˆåŒ…æ‹¬æ‰€æœ‰ç·¨è§£ç¢¼å™¨ï¼‰
        $ultimateLibs = @(
          "avcodec.lib", "avformat.lib", "avutil.lib", "swscale.lib", 
          "swresample.lib", "avfilter.lib", "avdevice.lib",
          "x264.lib", "x265.lib", "aom.lib", "vpx.lib", 
          "svtav1enc.lib", "rav1e.lib", "vvenc.lib", "vvdec.lib",
          "xeve.lib", "xevd.lib", "mp3lame.lib", "opus.lib",
          "ogg.lib", "flac.lib", "vorbis.lib", "vorbisenc.lib",
          "ass.lib", "freetype.lib", "fribidi.lib", "harfbuzz.lib"
        ) -join ";"
        
        $content = $content -replace '(<AdditionalDependencies>)', "`$1$ultimateLibs;"
        
        # æ·»åŠ ç³»çµ±åº«
        $systemLibs = "ws2_32.lib;secur32.lib;bcrypt.lib;winmm.lib;dxguid.lib;"
        $content = $content -replace '(<AdditionalDependencies>[^<]*)', "`$0$systemLibs"
        
        $content | Out-File $vcxprojPath -Encoding UTF8
        Write-Host "Successfully patched: $vcxprojPath"

        # å°‹æ‰¾ä¸¦ä¿®æ”¹éæ¿¾å™¨å°ˆæ¡ˆæ–‡ä»¶
        $filtersPossiblePaths = @(
          "src\filters\filters.vcxproj",
          "filters\filters.vcxproj",
          "src\DSUtil\DSUtil.vcxproj"
        )
        
        foreach ($filtersPath in $filtersPossiblePaths) {
          if (Test-Path $filtersPath) {
            Write-Host "Found filters project: $filtersPath"
            $filtersContent = Get-Content $filtersPath -Raw
            $filtersContent = $filtersContent -replace '(<AdditionalIncludeDirectories>)', "`$1$ffmpegInclude;"
            $filtersContent = $filtersContent -replace '(<AdditionalLibraryDirectories>)', "`$1$ffmpegLibDir;"
            $filtersContent | Out-File $filtersPath -Encoding UTF8
            Write-Host "Successfully patched filters project: $filtersPath"
            break
          }
        }

    - name: Find and prepare build solution
      shell: powershell
      run: |
        # æ‰¾åˆ°ä¸»è§£æ±ºæ–¹æ¡ˆæ–‡ä»¶
        $possibleSolutions = @(
          "mpc-be.sln",
          "src\mpc-be.sln", 
          "mpc-be_2022.sln",
          "build\mpc-be.sln"
        )
        
        $solutionPath = $null
        foreach ($path in $possibleSolutions) {
          if (Test-Path $path) {
            $solutionPath = $path
            Write-Host "Found solution file: $path"
            break
          }
        }
        
        if (-not $solutionPath) {
          # æœç´¢æ‰€æœ‰è§£æ±ºæ–¹æ¡ˆæ–‡ä»¶
          $allSolutions = Get-ChildItem -Recurse -Filter "*.sln"
          if ($allSolutions.Count -gt 0) {
            $solutionPath = $allSolutions[0].FullName
            Write-Host "Found alternative solution: $solutionPath"
          } else {
            Write-Error "Could not find solution file"
            exit 1
          }
        }
        
        echo "SOLUTION_PATH=$solutionPath" >> $env:GITHUB_ENV

    - name: Retarget solution for compatible SDK
      shell: powershell
      run: |
        $GITHUB_WORKSPACE\.github\external\retarget.ps1
        
    - name: Validate project files structure
      shell: powershell
      run: |
        Write-Host "Validating project files..."
        
        $projectFiles = Get-ChildItem -Recurse -Filter "*.vcxproj"
        $validationErrors = @()
        
        foreach ($proj in $projectFiles) {
          try {
            # å˜—è©¦è¼‰å…¥ XML ä¾†é©—è­‰çµæ§‹
            [xml]$xmlContent = Get-Content $proj.FullName -Raw
            
            # æª¢æŸ¥é—œéµå…ƒç´ 
            $propertyGroups = $xmlContent.Project.PropertyGroup
            $hasWindowsSDK = $false
            $hasPlatformToolset = $false
            
            foreach ($pg in $propertyGroups) {
              if ($pg.WindowsTargetPlatformVersion) {
                $hasWindowsSDK = $true
                Write-Host "  âœ… $($proj.Name): WindowsTargetPlatformVersion = $($pg.WindowsTargetPlatformVersion)"
              }
              if ($pg.PlatformToolset) {
                $hasPlatformToolset = $true
                Write-Host "  âœ… $($proj.Name): PlatformToolset = $($pg.PlatformToolset)"
              }
            }
            
            if (-not $hasWindowsSDK) {
              $validationErrors += "$($proj.Name): Missing WindowsTargetPlatformVersion"
            }
            if (-not $hasPlatformToolset) {
              $validationErrors += "$($proj.Name): Missing PlatformToolset"
            }
            
          } catch {
            $validationErrors += "$($proj.Name): XML parsing failed - $($_.Exception.Message)"
            
            # å˜—è©¦ä¿®å¾© XML çµæ§‹å•é¡Œ
            Write-Host "  ğŸ”§ Attempting to fix XML structure in $($proj.Name)"
            $content = Get-Content $proj.FullName -Raw
            
            # ä¿®å¾©å¸¸è¦‹çš„ XML å•é¡Œ
            $content = $content -replace '&(?!amp;|lt;|gt;|quot;|apos;)', '&amp;'
            $content = $content -replace '<(\s)', '&lt;$1'
            
            # ç¢ºä¿æ­£ç¢ºçš„ XML æ ¼å¼
            if ($content -notmatch '^\s*<\?xml') {
              $content = '<?xml version="1.0" encoding="utf-8"?>' + "`n" + $content
            }
            
            try {
              [xml]$fixedXml = $content
              $content | Out-File $proj.FullName -Encoding UTF8 -NoNewline
              Write-Host "  âœ… Fixed XML structure in $($proj.Name)"
            } catch {
              Write-Warning "  âŒ Could not fix XML structure in $($proj.Name)"
            }
          }
        }
        
        if ($validationErrors.Count -gt 0) {
          Write-Host "`nâš ï¸  Validation Issues Found:"
          $validationErrors | ForEach-Object { Write-Host "  - $_" }
        } else {
          Write-Host "`nâœ… All project files validated successfully"
        }

    - name: Alternative project fix (if validation failed)
      if: failure()
      shell: powershell
      run: |
        $GITHUB_WORKSPACE\.github\external\alternative.ps1
        
    - name: XML-based project file repair
      shell: powershell
      run: |
        $platform = "${{ matrix.platform }}"
        $configuration = "${{ matrix.configuration }}"
        
        Write-Host "Performing XML-based project file repair..."
        
        $projectFiles = Get-ChildItem -Recurse -Filter "*.vcxproj"
        
        foreach ($proj in $projectFiles) {
          try {
            Write-Host "Processing: $($proj.Name)"
            
            # è¼‰å…¥ XML æ–‡æª”
            [xml]$xmlDoc = Get-Content $proj.FullName -Encoding UTF8
            
            # ç¢ºä¿æœ‰ xmlns å±¬æ€§
            if (-not $xmlDoc.Project.GetAttribute("xmlns")) {
              $xmlDoc.Project.SetAttribute("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003")
            }
            
            # æŸ¥æ‰¾æˆ–å‰µå»ºå…¨å±€ PropertyGroup
            $globalPropertyGroup = $xmlDoc.Project.PropertyGroup | Where-Object { 
              $_.Configuration -or $_.Platform -or (-not $_.Condition) 
            } | Select-Object -First 1
            
            if (-not $globalPropertyGroup) {
              # å‰µå»ºæ–°çš„å…¨å±€ PropertyGroup
              $globalPropertyGroup = $xmlDoc.CreateElement("PropertyGroup", $xmlDoc.Project.NamespaceURI)
              $xmlDoc.Project.InsertBefore($globalPropertyGroup, $xmlDoc.Project.FirstChild)
            }
            
            # è¨­ç½®æˆ–æ›´æ–° WindowsTargetPlatformVersion
            $windowsSDKElement = $globalPropertyGroup.WindowsTargetPlatformVersion
            if ($windowsSDKElement) {
              $windowsSDKElement.InnerText = $env:WINDOWS_SDK_VERSION
            } else {
              $windowsSDKElement = $xmlDoc.CreateElement("WindowsTargetPlatformVersion", $xmlDoc.Project.NamespaceURI)
              $windowsSDKElement.InnerText = $env:WINDOWS_SDK_VERSION
              $globalPropertyGroup.AppendChild($windowsSDKElement) | Out-Null
            }
            
            # è¨­ç½®æˆ–æ›´æ–° PlatformToolset
            $toolsetElement = $globalPropertyGroup.PlatformToolset
            if ($toolsetElement) {
              $toolsetElement.InnerText = "v143"
            } else {
              $toolsetElement = $xmlDoc.CreateElement("PlatformToolset", $xmlDoc.Project.NamespaceURI)
              $toolsetElement.InnerText = "v143"
              $globalPropertyGroup.AppendChild($toolsetElement) | Out-Null
            }
            
            # ä¿å­˜æ–‡æª”
            $xmlDoc.Save($proj.FullName)
            Write-Host "  âœ… Successfully repaired: $($proj.Name)"
            
          } catch {
            Write-Warning "  âŒ Failed to repair $($proj.Name): $($_.Exception.Message)"
            
            # å›é€€åˆ°æ–‡æœ¬æ›¿æ›æ–¹æ³•
            try {
              $content = Get-Content $proj.FullName -Raw -Encoding UTF8
              
              # ç°¡å–®çš„æ–‡æœ¬æ›¿æ›ä½œç‚ºå¾Œå‚™
              if ($content -notmatch '<WindowsTargetPlatformVersion>') {
                $content = $content -replace '(<Project[^>]*>)', "`$1`n  <PropertyGroup>`n    <WindowsTargetPlatformVersion>$env:WINDOWS_SDK_VERSION</WindowsTargetPlatformVersion>`n    <PlatformToolset>v143</PlatformToolset>`n  </PropertyGroup>"
                $content | Out-File $proj.FullName -Encoding UTF8 -NoNewline
                Write-Host "  ğŸ”§ Applied fallback fix to: $($proj.Name)"
              }
            } catch {
              Write-Error "  ğŸ’¥ Complete failure to fix: $($proj.Name)"
            }
          }
        }
        
        Write-Host "`nXML-based repair completed"
        
        # è¨­ç½®ç·¨è­¯åƒæ•¸
        $buildArgs = @(
          "`"$env:SOLUTION_PATH`""
          "/p:Configuration=$configuration"
          "/p:Platform=$platform"
          "/p:WindowsTargetPlatformVersion=$env:WINDOWS_SDK_VERSION"
          "/p:PlatformToolset=v143"
          "/p:UseEnv=true"
          "/p:PreferredToolArchitecture=x64"
          "/p:EnableClangTidyCodeAnalysis=false"
          "/m"
          "/verbosity:minimal"
          "/p:WarningLevel=1"
          "/nr:false"
          "/p:BuildInParallel=true"
          "/maxcpucount"
        )
        
        # å¦‚æœæ‰¾åˆ°äº† VC Targets è·¯å¾„ï¼Œæ·»åŠ å®ƒ
        if ($env:VC_TARGETS_PATH -and (Test-Path $env:VC_TARGETS_PATH)) {
          $quotedVCTargetsPath = "`"$env:VC_TARGETS_PATH`""
          $buildArgs += "/p:VCTargetsPath=$quotedVCTargetsPath"
        }
        
        # è¨­ç½®é¡å¤–çš„ç’°å¢ƒè®Šæ•¸
        $env:UseEnv = "true"
        $env:INCLUDE = "$env:FFMPEG_ROOT\include;$env:INCLUDE"
        $env:LIB = "$env:FFMPEG_ROOT\lib;$env:LIB"
        
        if ("${{ github.event.inputs.include_debug_symbols }}" -eq "true") {
          $buildArgs += "/p:GenerateDebugInformation=true"
        }
        
        Write-Host "Starting build with arguments:"
        $buildArgs | ForEach-Object { Write-Host "  $_" }
        
        # åŸ·è¡Œç·¨è­¯
        $buildProcess = Start-Process -FilePath "msbuild" -ArgumentList $buildArgs -Wait -PassThru -NoNewWindow -RedirectStandardOutput "$env:TEMP\build_output.log" -RedirectStandardError "$env:TEMP\build_error.log"
        
        # æª¢æŸ¥ç·¨è­¯çµæœ
        $buildResult = $buildProcess
        
        # é¡¯ç¤ºç·¨è­¯è¼¸å‡º
        if (Test-Path "$env:TEMP\build_output.log") {
          Write-Host "`n=== Build Output ==="
          Get-Content "$env:TEMP\build_output.log" | Select-Object -Last 50
        }
        
        if (Test-Path "$env:TEMP\build_error.log") {
          $errorContent = Get-Content "$env:TEMP\build_error.log" -Raw
          if ($errorContent.Trim()) {
            Write-Host "`n=== Build Errors ==="
            Write-Host $errorContent
          }
        }
        if ($buildResult.ExitCode -ne 0) {
          Write-Warning "Build failed with exit code: $($buildResult.ExitCode)"
          
          # å˜—è©¦è¨ºæ–·å•é¡Œ
          Write-Host "`n=== Build Diagnostics ==="
          Write-Host "SDK Version: $env:WINDOWS_SDK_VERSION"
          Write-Host "Platform Toolset: v143"
          Write-Host "Solution Path: $env:SOLUTION_PATH"
          
          # è®€å–éŒ¯èª¤å…§å®¹é€²è¡Œåˆ†æ
          $errorContent = ""
          if (Test-Path "$env:TEMP\build_error.log") {
            $errorContent = Get-Content "$env:TEMP\build_error.log" -Raw
          }
          
          # æª¢æŸ¥å¸¸è¦‹å•é¡Œ
          if ($errorContent -match "MSB8036" -or $errorContent -match "Windows SDK.*was not found") {
            Write-Host "âŒ Windows SDK version issue detected"
            Write-Host "Available SDKs:"
            Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\Include" -ErrorAction SilentlyContinue | Select-Object Name
            
            # å˜—è©¦ä½¿ç”¨å‚™ç”¨ SDK ç‰ˆæœ¬é‡æ–°ç·¨è­¯
            $fallbackSDKs = @("10.0.22621.0", "10.0.19041.0", "10.0.18362.0", "10.0.17763.0")
            foreach ($fallbackSDK in $fallbackSDKs) {
              $sdkPath = "C:\Program Files (x86)\Windows Kits\10\Include\$fallbackSDK"
              if (Test-Path $sdkPath) {
                Write-Host "Trying fallback SDK: $fallbackSDK"
                
                # ä¿®æ”¹ç·¨è­¯åƒæ•¸ä¸­çš„ SDK ç‰ˆæœ¬
                $fallbackArgs = @()
                foreach ($arg in $buildArgs) {
                  if ($arg -like "*WindowsTargetPlatformVersion*") {
                    $fallbackArgs += "/p:WindowsTargetPlatformVersion=$fallbackSDK"
                  } else {
                    $fallbackArgs += $arg
                  }
                }
                
                Write-Host "Retrying build with SDK $fallbackSDK..."
                $retryProcess = Start-Process -FilePath "msbuild" -ArgumentList $fallbackArgs -Wait -PassThru -NoNewWindow
                
                if ($retryProcess.ExitCode -eq 0) {
                  Write-Host "âœ… Build succeeded with fallback SDK: $fallbackSDK"
                  return
                }
              }
            }
          }
          
          if ($errorContent -match "MSB8020") {
            Write-Host "âŒ Platform toolset issue detected"
            Write-Host "Trying with different toolset..."
            
            # å˜—è©¦ v142 å·¥å…·é›†
            $toolsetArgs = @()
            foreach ($arg in $buildArgs) {
              if ($arg -like "*PlatformToolset*") {
                $toolsetArgs += "/p:PlatformToolset=v142"
              } else {
                $toolsetArgs += $arg
              }
            }
            
            $retryProcess = Start-Process -FilePath "msbuild" -ArgumentList $toolsetArgs -Wait -PassThru -NoNewWindow
            if ($retryProcess.ExitCode -eq 0) {
              Write-Host "âœ… Build succeeded with v142 toolset"
              return
            }
          }
          
          Write-Error "âŒ All build attempts failed"
          exit 1
        } else {
          Write-Host "âœ… Build completed successfully"
        }

    - name: Test MPC-BE Ultimate build
      shell: powershell
      run: |
        $platform = "${{ matrix.platform }}"
        $configuration = "${{ matrix.configuration }}"
        
        # æœç´¢å¯èƒ½çš„è¼¸å‡ºç›®éŒ„
        $possibleOutputs = @(
          "bin\mpc-be_$platform\$configuration",
          "bin\$platform\$configuration",
          "bin\$configuration",
          "x64\$configuration",
          "$configuration"
        )
        
        $exeName = if ($platform -eq "x86") { "mpc-be.exe" } else { "mpc-be64.exe" }
        $alternativeNames = @($exeName, "mpc-be.exe", "MPC-BE64.exe", "MPC-BE.exe")
        
        $foundExe = $null
        foreach ($outputDir in $possibleOutputs) {
          if (Test-Path $outputDir) {
            foreach ($name in $alternativeNames) {
              $fullPath = Join-Path $outputDir $name
              if (Test-Path $fullPath) {
                $foundExe = $fullPath
                break
              }
            }
            if ($foundExe) { break }
          }
        }
        
        if (-not $foundExe) {
          Write-Host "Searching for MPC-BE executable..."
          $allExes = Get-ChildItem -Recurse -Filter "*.exe" | Where-Object { $_.Name -like "*mpc*" -or $_.Name -like "*MPC*" }
          if ($allExes.Count -gt 0) {
            $foundExe = $allExes[0].FullName
            Write-Host "Found executable: $foundExe"
          } else {
            Write-Error "âŒ MPC-BE Ultimate build failed - no executable found"
            Write-Host "Available files in bin directories:"
            Get-ChildItem -Recurse -Path "bin" -ErrorAction SilentlyContinue | Select-Object Name, Directory
            exit 1
          }
        }
        
        if ($foundExe) {
          Write-Host "âœ… MPC-BE Ultimate build successful: $foundExe"
          $fileInfo = Get-Item $foundExe
          Write-Host "File size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
          echo "BUILT_EXE_PATH=$foundExe" >> $env:GITHUB_ENV
          
          # æª¢æŸ¥ä¾è³´çš„ DLLï¼ˆæ‡‰è©²å¾ˆå°‘ï¼Œå› ç‚ºæ˜¯éœæ…‹é€£çµï¼‰
          Write-Host "`nDependencies:"
          try {
            dumpbin /dependents $foundExe | Select-String "\.dll"
          } catch {
            Write-Host "Could not analyze dependencies (dumpbin not available)"
          }
        }

    - name: Package MPC-BE Ultimate
      shell: powershell
      run: |
        $platform = "${{ matrix.platform }}"
        $configuration = "${{ matrix.configuration }}"
        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm"
        $packageName = "MPC-BE-Ultimate-$platform-$configuration-$timestamp"
        
        New-Item -ItemType Directory -Path $packageName -Force
        
        # è¤‡è£½ä¸»ç¨‹åº
        if ($env:BUILT_EXE_PATH) {
          $sourcePath = $env:BUILT_EXE_PATH
          $fileName = Split-Path $sourcePath -Leaf
          
          Copy-Item $sourcePath "$packageName\"
          Write-Host "Copied: $sourcePath -> $packageName\$fileName"
          
          # é‡å‘½åç‚ºæ›´æ¸…æ¥šçš„åç¨±
          $newName = "MPC-BE-Ultimate-$platform.exe"
          Rename-Item "$packageName\$fileName" $newName
          Write-Host "Renamed to: $newName"
        } else {
          Write-Warning "No executable path found to package"
        }
        
        # è¤‡è£½æ–‡æª”å’Œæˆæ¬Šæ–‡ä»¶
        $docFiles = @("COPYING.txt", "readme.txt", "AUTHORS", "CHANGELOG", "LICENSE")
        foreach ($file in $docFiles) {
          if (Test-Path $file) {
            Copy-Item $file "$packageName\"
            Write-Host "Copied documentation: $file"
          }
        }
        
        # æœç´¢ä¸¦è¤‡è£½å¯èƒ½çš„æ–‡æª”æ–‡ä»¶
        $foundDocs = Get-ChildItem -Recurse -Filter "*.txt" | Where-Object { 
          $_.Name -match "(readme|license|copying|changelog|authors)" 
        } | Select-Object -First 5
        
        foreach ($doc in $foundDocs) {
          $destPath = "$packageName\$($doc.Name)"
          if (-not (Test-Path $destPath)) {
            Copy-Item $doc.FullName $destPath
            Write-Host "Found and copied: $($doc.Name)"
          }
        }
        
        # å‰µå»ºèªªæ˜æ–‡ä»¶
        $readmeContent = @"
        MPC-BE Ultimate Build
        ====================
        
        Build Information:
        - Platform: $platform
        - Configuration: $configuration  
        - Build Date: $timestamp
        - FFmpeg: Ultimate static build with latest codecs
        
        Supported Codecs:
        - Video: H.264, H.265/HEVC, AV1, VP8/VP9, VVC/H.266, EVC
        - Audio: AAC, MP3, Opus, FLAC, Vorbis
        - Hardware Acceleration: DXVA2, D3D11VA, NVDEC, QuickSync
        
        This build includes the latest video codecs and optimizations.
        All libraries are statically linked for maximum compatibility.
        "@
        
        $readmeContent | Out-File "$packageName\README-Ultimate.txt" -Encoding UTF8
        
        # å‰µå»ºç‰ˆæœ¬ä¿¡æ¯
        $buildInfo = @{
          "build_date" = $timestamp
          "platform" = $platform
          "configuration" = $configuration
          "ffmpeg_version" = "Ultimate Static Build"
          "supported_codecs" = @("H.264", "H.265", "AV1", "VP8", "VP9", "VVC", "EVC")
          "hardware_acceleration" = @("DXVA2", "D3D11VA", "NVDEC", "QuickSync")
          "static_linking" = $true
        } | ConvertTo-Json -Depth 3
        
        $buildInfo | Out-File "$packageName\build-info.json" -Encoding UTF8
        
        echo "PACKAGE_NAME=$packageName" >> $env:GITHUB_ENV
        
        # é¡¯ç¤ºæ‰“åŒ…çµæœ
        Write-Host "`nPackage contents:"
        Get-ChildItem $packageName | Format-Table Name, Length

    - name: Upload MPC-BE Ultimate
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.PACKAGE_NAME }}
        path: ${{ env.PACKAGE_NAME }}/
        retention-days: 30

    - name: Save FFmpeg cache (if built)
      if: needs.build-ultimate-ffmpeg.outputs.ffmpeg-cache-hit != 'true' && success()
      uses: actions/cache/save@v4
      with:
        path: |
          D:/ffmpeg-build/
        key: ${{ needs.build-ultimate-ffmpeg.outputs.ffmpeg-cache-key }}

    - name: Debug build environment (if build fails)
      if: failure()
      shell: powershell
      run: |
        Write-Host "=== Build Environment Debug Information ==="
        
        Write-Host "`n--- Environment Variables ---"
        Get-ChildItem Env: | Where-Object { $_.Name -match "(SDK|VS|INCLUDE|LIB|PATH)" } | Sort-Object Name
        
        Write-Host "`n--- MSBuild Information ---"
        msbuild -version
        
        Write-Host "`n--- Available Windows SDKs ---"
        $sdkPaths = @(
          "C:\Program Files (x86)\Windows Kits\10\Include",
          "C:\Program Files\Windows Kits\10\Include"
        )
        foreach ($path in $sdkPaths) {
          if (Test-Path $path) {
            Write-Host "Path: $path"
            Get-ChildItem $path | Where-Object { $_.Name -match "^10\." } | ForEach-Object {
              Write-Host "  - $($_.Name)"
            }
          }
        }
        
        Write-Host "`n--- Visual Studio Components ---"
        $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
        if (Test-Path $vsWhere) {
          & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64
          & $vsWhere -latest -products * -requires Microsoft.Component.MSBuild
        }
        
        Write-Host "`n--- Project Files Content Sample ---"
        $sampleProj = Get-ChildItem -Recurse -Filter "*.vcxproj" | Select-Object -First 1
        if ($sampleProj) {
          Write-Host "Sample from: $($sampleProj.FullName)"
          Get-Content $sampleProj.FullName | Select-String -Pattern "(WindowsTargetPlatformVersion|PlatformToolset)" | Select-Object -First 5
        }
        
        Write-Host "`n--- Build Logs ---"
        if (Test-Path "$env:TEMP\build_error.log") {
          Write-Host "Error log content:"
          Get-Content "$env:TEMP\build_error.log" | Select-Object -Last 100
        }
        
        if (Test-Path "$env:TEMP\build_output.log") {
          Write-Host "Output log content:"
          Get-Content "$env:TEMP\build_output.log" | Select-Object -Last 50
        }
        
  create-ultimate-release:
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    needs: [build-ultimate-ffmpeg, build-mpc-be]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      
    - name: Create release packages
      run: |
        # å‰µå»ºç™¼å¸ƒåŒ…
        for dir in MPC-BE-Ultimate-*/; do
          if [ -d "$dir" ]; then
            archive_name="${dir%/}.7z"
            7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=32m -ms=on "$archive_name" "$dir"*
            echo "Created: $archive_name"
          fi
        done
        
        ls -la *.7z

    - name: Generate release info
      id: release-info
      run: |
        TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
        TAG="ultimate-$(date -u +"%Y%m%d-%H%M%S")"
        
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT

    - name: Create Ultimate Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release-info.outputs.tag }}
        name: "MPC-BE Ultimate ${{ steps.release-info.outputs.tag }}"
        body: |
          # MPC-BE Ultimate Build ğŸš€
          
          **The most advanced MPC-BE build with cutting-edge video codec support!**
          
          ## ğŸ¥ Supported Video Codecs
          - **H.264/AVC** - Industry standard
          - **H.265/HEVC** - 4K/8K ready  
          - **AV1** - Next-gen efficiency
          - **VP8/VP9** - Web optimized
          - **VVC/H.266** - Future standard â­
          - **EVC** - MPEG-5 Essential Video Coding â­
          
          ## ğŸµ Audio Codecs
          - AAC, MP3, Opus, FLAC, Vorbis, OGG
          
          ## âš¡ Hardware Acceleration
          - DXVA2, D3D11VA, NVIDIA NVDEC, Intel QuickSync
          
          ## ğŸ“¦ Build Details
          - **Build Date**: ${{ steps.release-info.outputs.timestamp }}
          - **FFmpeg**: Ultimate static build with all codecs
          - **Optimization**: x86-64-v2 with AVX2 support
          - **Linking**: Fully static (no external dependencies)
          
          ## ğŸ“‹ Variants
          - **x64 Release**: Optimized for production use
          - **x64 Debug**: For development and debugging
          
          **Note**: This build includes experimental codecs and the latest video standards. Perfect for enthusiasts and professionals who need the most comprehensive codec support.
        files: |
          *.7z
        draft: false
        prerelease: false
